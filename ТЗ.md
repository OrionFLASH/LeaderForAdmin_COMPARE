# Техническое задание:

## Универсальный парсер и инструмент сравнения JSON-файлов турниров

---

### 1. **Парсинг и обработка JSON-файлов турниров**

#### 1.1. **Входные данные**

* Каждый входной файл — JSON-объект, где:

  * Ключ верхнего уровня: `tournamentId` (например, `"t_01_2025-1_05-1_1_3021"`).
  * Значение по ключу:

    * **Словарь** с ключами `success`, `body`, в `body` — вложенный `tournament`;
    * **Список** таких словарей (если по одному id несколько турниров);
    * В редких случаях — ошибочные значения (`True`, `str`, `int`, `None`).
      Такие случаи игнорировать (warning в лог).

#### 1.2. **Обработка структуры турнира**

* Для каждого турнира по ключу `tournamentId`:

  * Если значение — список, обработать каждый элемент как отдельный турнир.
  * Если значение — словарь, обработать как один турнир.
  * Если иной тип — пропустить с предупреждением в лог.

* В каждом record по пути `body` → `tournament`:

  * Извлекать `tournamentId` (или использовать ключ, если поле отсутствует).
  * Извлекать все ключи турнира для последующего анализа.

#### 1.3. **Парсинг лидеров (leaders)**

* Внутри `tournament` искать поле `leaders`:

  * Если **массив** — использовать как есть.
  * Если **словарь** — преобразовать в список значений.
  * Если отсутствует, None или пусто — считать, что лидеров нет.
* Если лидеров нет (пустой список/словарь) — добавить заглушку:

  * `employeeNumber`: `'00000000'`
  * `lastName`: `'None'`
  * `firstName`: `'None'`
  * `SourceFile`, `tournamentId`, все числовые поля = None.
* Если лидеры есть — для каждого формировать плоскую строку для экспорта.

#### 1.4. **Обработка числовых полей**

* Для всех полей из `FLOAT_FIELDS` и `INT_FIELDS`:

  * Использовать функции `parse_float`, `parse_int` с учетом особенностей формата (разделители, пробелы, мусор).
  * Ошибка преобразования — None.

#### 1.5. **Распаковка вложенных массивов**

* Для поля `divisionRatings` у каждого лидера:

  * Для каждого rating создавать отдельные колонки: `divisionRatings_{groupCode}_{field}`
  * Если поле отсутствует — None.

#### 1.6. **Итоговая агрегация**

* Все строки агрегируются в pandas DataFrame.
* В итоговой таблице:

  * `SourceFile`, `tournamentId`, все ключевые поля лидера, все числовые поля, все колонки для вложенных групп.

---

### 2. **Сравнение файлов**

#### 2.1. **Базовые принципы**

* Оба файла предварительно парсятся по вышеуказанным правилам.
* Для сравнения используются:

  * `tournamentId`,
  * `employeeNumber`
* Сравниваются все числовые и основные поля для совпадающих участников по каждому турниру.

#### 2.2. **Результат сравнения**

* Формируется таблица-отчет:

  * Все отличия по значимым полям (показать старое/новое значение).
  * Записи, которые есть только в одном из файлов — явно пометить, в каком именно они есть.
  * Если по `tournamentId` в одном файле нет участников, а в другом есть — это отображается отдельно.

#### 2.3. **Обработка ошибок**

* Все ошибки и подозрительные места фиксируются в логах (файл, ключ турнира, ключ сотрудника, суть ошибки).
* Ошибки одного участника/турнира не прерывают обработку остальных.

---

### 3. **Требования к коду и логированию**

* Код должен быть универсален: поддержка dict, list, разных вложений.
* Логирование:

  * Стандартный модуль `logging` (файл и консоль).
  * Логировать: путь к файлу, ключ турнира, ключ сотрудника, тип ошибки.
* Критические ошибки не должны останавливать обработку других файлов/турниров.

---

### 4. **Требования к результату**

* После парсинга — готовый CSV/XLS-файл (плоская таблица лидеров и всех полей).
* После сравнения — CSV/XLS-отчет по отличиям.
* Файлы должны быть готовы для анализа в Excel.

---

### 5. **Примеры и пояснения**

* Любые пустые или некорректные турниры (leaders пустой, True, None и т.д.) игнорировать или добавлять только заглушку.
* Для leaders типа dict — всегда превращать в список.
* Преобразования float/int устойчивы к любому формату чисел.
* Поля, которых нет в исходных данных, но есть в списке числовых — добавлять как None.

#### Пример заглушки:

```python
{
  "SourceFile": "LFA_1.json",
  "tournamentId": "t_01_2025-1_02-3_1t_3051",
  "employeeNumber": "00000000",
  "lastName": "None",
  "firstName": "None",
  ... # остальные поля = None
}
```

#### Пример распаковки divisionRatings:

```python
"divisionRatings_BANK_placeInRating": "1",
"divisionRatings_TB_placeInRating": "2",
...
```

---

### 6. **Тестовые сценарии**

1. Несколько турниров в одном файле (с разной структурой leaders).
2. Турнир с пустыми/отсутствующими участниками.
3. Ошибочный тип значения турнира (`True`, `None`).
4. Ошибочный тип лидера (`str`, `None`).
5. Вложенные поля с разной вложенностью.
6. Числовые поля в разных форматах ("1 000,32").
7. Файлы с одной/многими записями.

---